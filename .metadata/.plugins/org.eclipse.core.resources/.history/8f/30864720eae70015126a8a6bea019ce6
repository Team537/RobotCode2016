#ifndef DRIVETRAIN_HPP
#define DRIVETRAIN_HPP

#include <Schematic.hpp>
#include <Toolbox/ErrorTimeCubed.hpp>
#include <Toolbox/RobotButton.hpp>
#include <Vision/Vision.hpp>

class DrivePIDSource: public PIDSource
{
    private:
        double target;
    public:
        DrivePIDSource()
        {
            target = -1;
        }

        void SetPIDSourceType(PIDSourceType pidSource)
        {
            m_pidSource = pidSource;
        }

        void SetPIDTarget(double center)
        {
            target = center;
        }

        double PIDGet()
        {
            return target;
        }
};

class DrivePIDOutput: public PIDOutput
{
    private:
        float output;
    public:
        DrivePIDOutput()
        {
            output = 0;
        }

        void PIDWrite(float output)
        {
            this->output = output;
        }

        float GetOutput()
        {
            return output;
        }
};

class DriveTrain: public IComponent
{
    private:
        CANTalon *leftDriveMaster, *leftDriveSlave1, *leftDriveSlave2;
        CANTalon *rightDriveMaster, *rightDriveSlave1, *rightDriveSlave2;

        Solenoid *shift;
        AHRS *gyro;
        Vision* vision;

        DrivePIDSource *visionPIDSource;
        DrivePIDOutput *visionPIDOutput;
        PIDController *visionPID;

        ErrorTimeCubed *angleETC;

        Timer *crossTime;
        bool hasCrossed;
        int crossState;
        bool isClimbing;

        RobotButton *shiftHigh, *shiftLow, *stateUntoggle, *autoCrossToggle;

        float crossSpeedMultiplier;
        bool crossingForward;

        float leftSpeedCurrent;
        float rightSpeedCurrent;

        int targetDistance;
        bool crossReverse;
        string stateNames[6] = {"None", "Auto Angle", "Auto Distance", "Crossing", "Teleop Control", "Teleop Shoot"};

    public:
        enum DriveState
        {
            NONE, AUTO_ANGLE, AUTO_DISTANCE, AUTO_TIMED, CROSSING, TELEOP_CONTROL, TELEOP_SHOOT
        };

        DriveState state;

        DriveTrain(Joystick* joystickPrimary, Joystick* joystickSecondary, AHRS *ahrs, Vision* visionTracking) :
                IComponent(joystickPrimary, joystickSecondary, new string("DriveTrain"))
        {
            // Left Master.
            leftDriveMaster = new CANTalon(1);
            leftDriveMaster->SetControlMode(CANTalon::ControlMode::kPosition);
            leftDriveMaster->SetFeedbackDevice(CANTalon::FeedbackDevice::QuadEncoder);

            // Left Slave.
            leftDriveSlave1 = new CANTalon(3);
            leftDriveSlave1->SetControlMode(CANTalon::ControlMode::kFollower);
            leftDriveSlave1->Enable();
            leftDriveSlave1->Set(1);

            // Left Slave.
            leftDriveSlave2 = new CANTalon(5);
            leftDriveSlave2->SetControlMode(CANTalon::ControlMode::kFollower);
            leftDriveSlave2->Enable();
            leftDriveSlave2->Set(1);

            // Right Master.
            rightDriveMaster = new CANTalon(2);
            rightDriveMaster->SetControlMode(CANTalon::ControlMode::kPosition);
            rightDriveMaster->SetFeedbackDevice(CANTalon::FeedbackDevice::QuadEncoder);
            rightDriveMaster->Enable();

            // Right Slave.
            rightDriveSlave1 = new CANTalon(4);
            rightDriveSlave1->SetControlMode(CANTalon::ControlMode::kFollower);
            rightDriveSlave1->Enable();
            rightDriveSlave1->Set(2);

            // Right Slave.
            rightDriveSlave2 = new CANTalon(6);
            rightDriveSlave2->SetControlMode(CANTalon::ControlMode::kFollower);
            rightDriveSlave2->Enable();
            rightDriveSlave2->Set(2);

            // Other robot objects.
            shift = new Solenoid(4);
            gyro = ahrs;
            vision = visionTracking;

            // Vision angle pids.
            visionPIDSource = new DrivePIDSource();
            visionPIDOutput = new DrivePIDOutput();
            visionPID = new PIDController(0.70f, 0, 0, visionPIDSource, visionPIDOutput);
            visionPID->SetInputRange(-1, 1);
            visionPID->SetOutputRange(-1, 1);
            visionPID->SetContinuous(true);
            visionPID->SetAbsoluteTolerance(0.05);
            visionPID->Disable();

            // Angle ETC.
            angleETC = new ErrorTimeCubed(DRIVE_ANGLE_TOLERANCE, 45.0f, -180.0f, 180.0f);

            // Crossing timers.
            crossTime = new Timer();
            hasCrossed = false;
            crossState = 0;
            isClimbing = true;

            // Teleop controls.
            shiftLow = new RobotButton(joystickPrimary, JOYSTICK_BUMPER_LEFT, false);
            shiftHigh = new RobotButton(joystickPrimary, JOYSTICK_BUMPER_RIGHT, false);
            stateUntoggle = new RobotButton(joystickPrimary, JOYSTICK_BACK, false);

#if NEW_JOYSTICK
            autoCrossToggle = new RobotButton(joystickPrimary, JOYSTICK_AXIS_TRIGGER_RIGHT, true);
#else
            autoCrossToggle = new RobotButton(joystickPrimary, JOYSTICK_TRIGGER_RIGHT, false);
#endif

            // Sets up the state;
            SetState(DriveState::NONE);

            // Initial drive speeds.
            crossSpeedMultiplier = 1.0f;
            crossingForward = true;

            leftSpeedCurrent = 0;
            rightSpeedCurrent = 0;
            targetDistance = 0;
            crossReverse = false;
        }

        void Update(bool teleop);
        bool DefenceCross();
        void Dashboard();

        void SetState(DriveState driveState);
        void Shift(bool highGear);

        void AutoAngle(float angleDegrees);
        void AutoDistance(int distanceIn);
        void AutoTimed(float seconds);
        void Cross(bool reverse, float speed);
        void SetCrossing(bool crossing);

        bool IsWaiting();
        bool IsTeleopControl();
        float GetCurrentDraw();
};

#endif
